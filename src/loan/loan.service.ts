import { Injectable } from '@nestjs/common';
import { Loan, LoanStatus } from 'src/postgres/entity/loan.entity';
import { CreateLoanDto } from './dto/create-loan.dto';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Emi } from 'src/postgres/entity/emi.entity';
import { take } from 'rxjs';

@Injectable()
export class LoanService {
  constructor(
    @InjectRepository(Loan)
    private readonly loanRepository: Repository<Loan>,
    @InjectRepository(Emi)
    private readonly emiRepository: Repository<Emi>,
  ) { }

  async createNewLoan(
    loanCreateReq: CreateLoanDto,
    username: string,
  ): Promise<Loan> {
    const loan = new Loan();
    loan.user_id = username;
    loan.amount = loanCreateReq.amount;
    loan.remaining_amount = loanCreateReq.amount;
    loan.periodicity = loanCreateReq.periodicity;
    loan.description = loanCreateReq.description;
    loan.status = LoanStatus.PENDING;
    loan.total_emis = loanCreateReq.total_emis;
    loan.remaining_emis = loan.total_emis;
    loan.emi_amount = Number(loan.amount / loan.total_emis);
    loan.transactional_logs = [new Date().valueOf() + ": Loan request has been generated by user"]
    const data = await this.loanRepository.save(loan);
    return data;
  }

  async cancelLoan(loanId: string, username: string): Promise<number> {
    const data = await this.loanRepository.findOne({
      where: {
        id: loanId,
        user_id: username,
      },
    });
    if (data) {
      if (data.status == LoanStatus.PENDING) {
        data.status = LoanStatus.CANCELLED;
        data.transactional_logs.push(new Date().valueOf() + ": Loan request has been cancelled by user" );
        await this.loanRepository.update({ id: loanId }, data);
        return 0;
      } else {
        return 1;
      }
    } else {
      return 2;
    }
  }

  async loanDetails(username: string, loanId: string): Promise<any> {
    const loan = await this.loanRepository.findOne({
      where: { id: loanId, user_id: username },
    });
    if (loan) {
      if (['PENDING', 'CANCELLED', 'REJECTED'].includes(loan.status)) {
        return loan;
      } else {
        const emis = await this.emiRepository.find({
          where: { loan_id: loanId }, order: { sequence: 'ASC' }
        });
        const res = {
          emis: emis,
          created_at: loan.created_at,
          updated_at: loan.updated_at,
          id: loan.id,
          amount: loan.amount,
          remaining_amount: loan.remaining_amount,
          user_id: loan.user_id,
          periodicity: loan.periodicity,
          total_emis: loan.total_emis,
          remaining_emis: loan.remaining_emis,
          description: loan.description,
          admin_comments: loan.admin_comments,
          approval_date: loan.approval_date,
          status: loan.status,
          transactional_logs :loan.transactional_logs
        }
        return res;
      }
    } else {
      return null;
    }
  }

  async find(
    username: string,
    page: number,
    per_page: number,
  ): Promise<{
    results: Loan[];
    total: number;
    page: number;
    per_page: number;
  }> {
    const [result, total] = await this.loanRepository.findAndCount({
      where: { user_id: username },
      order: { updated_at: 'DESC' },
      take: per_page,
      skip: (page - 1) * per_page,
    });
    return {
      results: result,
      total: total,
      page: page,
      per_page: per_page,
    };
  }

  async loanRepayment(username: string, loanId: string, amount: number): Promise<{ error: boolean, message: string, data: any }> {
    const res = {
      message: 'Loan with specified id does not exist',
      data: null,
      error: true
    }
    const loan = await this.loanRepository.findOne({
      where: { id: loanId, user_id: username },
    });
    if (loan) {
      switch (loan.status) {
        case LoanStatus.PENDING:
          res.message = 'Loan is pending for admin approval';
          break;
        case LoanStatus.CANCELLED:
          res.message = 'Loan has been cancelled by user already';
          break;
        case LoanStatus.REJECTED:
          res.message = 'Loan has been rejected by admin';
          break;
        case LoanStatus.PAID:
          res.message = 'Loan has been paid already';
          break;
        case LoanStatus.APPROVED:
          if (loan.remaining_amount < amount) {
            res.message = 'Entered amount is greater than remaining amount';
            break;
          }
          if (loan.remaining_amount == amount) {
            res.error = false;
            res.message = 'Loan has been paid';
            loan.remaining_amount = 0;
            loan.remaining_emis = 0;
            loan.transactional_logs.push(new Date().valueOf() + ":amount(" + amount + ") Loan has been paid by user" );
            await this.loanRepository.update({ id: loanId }, loan);
            await this.emiRepository.update({ loan_id: loanId, status: 'PENDING' }, { status: 'PAID' })
            break;
          }
          if (loan.emi_amount == amount) {
            res.error = false;
            res.message = 'EMI has been paid';
            loan.remaining_amount = loan.remaining_amount - amount;
            loan.remaining_emis = loan.remaining_emis - 1;
            loan.transactional_logs.push(new Date().valueOf() + ":amount(" + amount + ") EMI has been paid by user" );
            await this.loanRepository.update({ id: loanId }, loan);
            const emi = await this.emiRepository.find({
              where: { loan_id: loanId, status: 'PENDING', },
              order: { sequence: 'ASC' },
              take: 1
            });
            emi[0].status = 'PAID';
            await this.emiRepository.update({ id: emi[0].id }, emi[0]);
            break;
          }
          if (loan.emi_amount > amount) {
            res.message = 'Specified amount is less than emi amount';
            break;
          }
          if (loan.emi_amount < amount) {
            res.error = false;
            res.message = 'EMI has been paid';
            loan.remaining_amount = loan.remaining_amount - amount;
            loan.remaining_emis = loan.remaining_emis - 1;
            loan.emi_amount = Math.ceil(loan.remaining_amount / loan.remaining_emis);
            loan.transactional_logs.push(new Date().valueOf() + ": amount(" + amount + ") EMI has been paid by user and additional amount has been settled" );
            await this.loanRepository.update({ id: loanId }, loan);
            const emi = await this.emiRepository.find({
              where: { loan_id: loanId, status: 'PENDING', },
              order: { sequence: 'ASC' },
              take: 1
            });
            emi[0].status = 'PAID';
            await this.emiRepository.update({ id: emi[0].id }, emi[0]);
            await this.emiRepository.update({ loan_id: loanId, status: 'PENDING' }, { amount: loan.emi_amount });
            break;
          }
      }

    }
    res.data = await this.loanDetails(username, loanId);
    return res;
  }
}
